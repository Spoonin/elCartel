// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Nact from "nact";
import * as Belt_List from "rescript/lib/es6/belt_List.js";
import * as Js_promise from "rescript/lib/es6/js_promise.js";
import * as Belt_Option from "rescript/lib/es6/belt_Option.js";
import * as Belt_SetString from "rescript/lib/es6/belt_SetString.js";
import * as Caml_exceptions from "rescript/lib/es6/caml_exceptions.js";
import * as Caml_js_exceptions from "rescript/lib/es6/caml_js_exceptions.js";
import * as References from "nact/lib/references";

function fromUntypedRef(reference) {
  return {
          TAG: "ActorRef",
          _0: reference
        };
}

function toUntypedRef(reference) {
  return reference._0;
}

function dispatch(prim0, prim1) {
  Nact.dispatch(prim0, prim1);
}

function dispatchWithSender(prim0, prim1, prim2) {
  Nact.dispatch(prim0, prim1, prim2);
}

var Interop = {
  fromUntypedRef: fromUntypedRef,
  toUntypedRef: toUntypedRef,
  dispatch: dispatch,
  dispatchWithSender: dispatchWithSender
};

function fromReference(actor) {
  return {
          TAG: "ActorPath",
          _0: actor._0.path
        };
}

function systemName(path) {
  return path._0.system;
}

function toString(path) {
  var path$1 = path._0;
  return "system:" + (path$1.system + ("//" + path$1.parts.join("/")));
}

function parts(path) {
  return Belt_List.fromArray(path._0.parts);
}

var ActorPath = {
  fromReference: fromReference,
  systemName: systemName,
  toString: toString,
  parts: parts
};

/* This code is to handle how bucklescript sometimes represents variants */

var WrappedVariant = '_wvariant';
var WrappedEvent = '_wevent';
function unsafeEncoder(obj) {
  var data = JSON.stringify(obj, function (key, value) {
    if (value && Array.isArray(value) && value.tag !== undefined) {
      var r = {};
      r.values = value.slice();
      r.tag = value.tag;
      r.type = WrappedVariant;
      return r;
    } else {
      return value;
    }
  });
  return { data: JSON.parse(data), type: WrappedEvent };
};

function unsafeDecoder(result) {
  if(result && typeof(result) === 'object' && result.type === WrappedEvent) {
    var serialized = result.serialized || JSON.stringify(result.data);
    return JSON.parse(serialized, (key, value) => {
      if (value && typeof (value) === 'object' && value.type === WrappedVariant) {
        var values = value.values;
        values.tag = value.tag;
        return values;
      } else {
        return value;
      }
    });
  } else {
    return result;
  }
};
;

function mapCtx(untypedCtx) {
  return {
          parent: {
            TAG: "ActorRef",
            _0: untypedCtx.parent
          },
          path: {
            TAG: "ActorPath",
            _0: untypedCtx.path
          },
          self: {
            TAG: "ActorRef",
            _0: untypedCtx.self
          },
          children: Belt_SetString.fromArray(Object.keys(untypedCtx.children)),
          name: untypedCtx.name,
          sender: untypedCtx.sender
        };
}

function mapPersistentCtx(untypedCtx) {
  return {
          parent: {
            TAG: "ActorRef",
            _0: untypedCtx.parent
          },
          path: {
            TAG: "ActorPath",
            _0: untypedCtx.path
          },
          self: {
            TAG: "ActorRef",
            _0: untypedCtx.self
          },
          name: untypedCtx.name,
          persist: untypedCtx.persist,
          children: Belt_SetString.fromArray(Object.keys(untypedCtx.children)),
          recovering: Belt_Option.getWithDefault(untypedCtx.recovering, false),
          sender: untypedCtx.sender
        };
}

function mapSupervisionCtx(untypedCtx) {
  return {
          parent: {
            TAG: "ActorRef",
            _0: untypedCtx.parent
          },
          path: {
            TAG: "ActorPath",
            _0: untypedCtx.path
          },
          self: {
            TAG: "ActorRef",
            _0: untypedCtx.self
          },
          name: untypedCtx.name,
          children: Belt_SetString.fromArray(Object.keys(untypedCtx.children)),
          sender: untypedCtx.sender
        };
}

function mapSupervisionFunction(optionalF) {
  if (optionalF !== undefined) {
    return (function (msg, err, ctx) {
              return Js_promise.then_((function (decision) {
                            var tmp;
                            switch (decision) {
                              case "Stop" :
                                  tmp = ctx.stop;
                                  break;
                              case "StopAll" :
                                  tmp = ctx.stopAll;
                                  break;
                              case "Reset" :
                                  tmp = ctx.reset;
                                  break;
                              case "ResetAll" :
                                  tmp = ctx.resetAll;
                                  break;
                              case "Escalate" :
                                  tmp = ctx.escalate;
                                  break;
                              case "Resume" :
                                  tmp = ctx.resume;
                                  break;
                              
                            }
                            return Promise.resolve(tmp);
                          }), optionalF(msg, err, mapSupervisionCtx(ctx)));
            });
  }
  
}

function useStatefulSupervisionPolicy(f, initialState) {
  var state = {
    contents: initialState
  };
  return function (msg, err, ctx) {
    var match = f(msg, err, state.contents, ctx);
    state.contents = match[0];
    return match[1];
  };
}

function spawn(name, shutdownAfter, onCrash, parent, func, initialState) {
  var options_initialStateFunc = (function (ctx) {
      return initialState(mapCtx(ctx));
    });
  var options_onCrash = mapSupervisionFunction(onCrash);
  var options = {
    initialStateFunc: options_initialStateFunc,
    shutdownAfter: shutdownAfter,
    onCrash: options_onCrash
  };
  var f = function (state, msg, ctx) {
    try {
      return func(state, msg, mapCtx(ctx));
    }
    catch (raw_err){
      return Promise.reject(Caml_js_exceptions.internalToOCamlException(raw_err));
    }
  };
  var untypedRef = Nact.spawn(parent._0, f, name, options);
  return {
          TAG: "ActorRef",
          _0: untypedRef
        };
}

function spawnStateless(name, shutdownAfter, parent, func) {
  var options_onCrash = mapSupervisionFunction(undefined);
  var options = {
    initialStateFunc: undefined,
    shutdownAfter: shutdownAfter,
    onCrash: options_onCrash
  };
  var f = function (msg, ctx) {
    try {
      return func(msg, mapCtx(ctx));
    }
    catch (raw_err){
      return Promise.reject(Caml_js_exceptions.internalToOCamlException(raw_err));
    }
  };
  var untypedRef = Nact.spawnStateless(parent._0, f, name, options);
  return {
          TAG: "ActorRef",
          _0: untypedRef
        };
}

function spawnPersistent(key, name, shutdownAfter, snapshotEvery, onCrash, decoder, stateDecoder, encoder, stateEncoder, parent, func, initialState) {
  var decoder$1 = Belt_Option.getWithDefault(decoder, (function (prim) {
          return unsafeDecoder(prim);
        }));
  var stateDecoder$1 = Belt_Option.getWithDefault(stateDecoder, (function (prim) {
          return unsafeDecoder(prim);
        }));
  var stateEncoder$1 = Belt_Option.getWithDefault(stateEncoder, (function (prim) {
          return unsafeEncoder(prim);
        }));
  var encoder$1 = Belt_Option.getWithDefault(encoder, (function (prim) {
          return unsafeEncoder(prim);
        }));
  var options_initialStateFunc = function (ctx) {
    return initialState(mapPersistentCtx(ctx));
  };
  var options_onCrash = mapSupervisionFunction(onCrash);
  var options = {
    initialStateFunc: options_initialStateFunc,
    shutdownAfter: shutdownAfter,
    snapshotEvery: snapshotEvery,
    onCrash: options_onCrash,
    decoder: decoder$1,
    encoder: encoder$1,
    snapshotEncoder: stateEncoder$1,
    snapshotDecoder: stateDecoder$1
  };
  var f = function (state, msg, ctx) {
    try {
      return func(state, msg, mapPersistentCtx(ctx));
    }
    catch (raw_err){
      return Promise.reject(Caml_js_exceptions.internalToOCamlException(raw_err));
    }
  };
  var untypedRef = Nact.spawnPersistent(parent._0, f, key, name, options);
  return {
          TAG: "ActorRef",
          _0: untypedRef
        };
}

function persistentQuery(key, snapshotKey, cacheDuration, snapshotEvery, decoder, stateDecoder, encoder, stateEncoder, actor, func, initialState) {
  var decoder$1 = Belt_Option.getWithDefault(decoder, (function (prim) {
          return unsafeDecoder(prim);
        }));
  var stateDecoder$1 = Belt_Option.getWithDefault(stateDecoder, (function (prim) {
          return unsafeDecoder(prim);
        }));
  var stateEncoder$1 = Belt_Option.getWithDefault(stateEncoder, (function (prim) {
          return unsafeEncoder(prim);
        }));
  var encoder$1 = Belt_Option.getWithDefault(encoder, (function (prim) {
          return unsafeEncoder(prim);
        }));
  var options = {
    initialState: initialState,
    cacheDuration: cacheDuration,
    snapshotEvery: snapshotEvery,
    decoder: decoder$1,
    snapshotKey: snapshotKey,
    encoder: encoder$1,
    snapshotEncoder: stateEncoder$1,
    snapshotDecoder: stateDecoder$1
  };
  var f = function (state, msg) {
    try {
      return func(state, msg);
    }
    catch (raw_err){
      return Promise.reject(Caml_js_exceptions.internalToOCamlException(raw_err));
    }
  };
  return Nact.persistentQuery(actor._0, f, key, options);
}

function stop(reference) {
  Nact.stop(reference._0);
}

function dispatch$1(recipient, msg) {
  Nact.dispatch(recipient._0, msg);
}

function nobody() {
  return {
          TAG: "ActorRef",
          _0: new References.Nobody()
        };
}

function spawnAdapter(name, parent, mapping) {
  var f = function (msg, param) {
    return Promise.resolve(dispatch$1(parent, mapping(msg)));
  };
  if (name !== undefined) {
    return spawnStateless(name, undefined, parent, f);
  } else {
    return spawnStateless(undefined, undefined, parent, f);
  }
}

function start(name, persistenceEngine, param) {
  var plugins = persistenceEngine !== undefined ? ({
        hd: Nact.configurePersistence(persistenceEngine),
        tl: /* [] */0
      }) : /* [] */0;
  var plugins$1 = name !== undefined ? ({
        hd: {
          name: name
        },
        tl: plugins
      }) : plugins;
  if (!plugins$1) {
    return {
            TAG: "ActorRef",
            _0: Nact.start()
          };
  }
  var match = plugins$1.tl;
  var a = plugins$1.hd;
  if (match) {
    return {
            TAG: "ActorRef",
            _0: Nact.start(a, match.hd)
          };
  } else {
    return {
            TAG: "ActorRef",
            _0: Nact.start(a)
          };
  }
}

var QueryTimeout = /* @__PURE__ */Caml_exceptions.create("Nact.QueryTimeout");

function query(timeout, recipient, msgF) {
  var f = function (tempReference) {
    return msgF({
                TAG: "ActorRef",
                _0: tempReference
              });
  };
  return Js_promise.$$catch((function (param) {
                return Promise.reject({
                            RE_EXN_ID: QueryTimeout,
                            _1: timeout
                          });
              }), Nact.query(recipient._0, f, timeout));
}

var seconds = 1000;

var minutes = Math.imul(60, seconds);

var hours = Math.imul(60, minutes);

function $less$neg$less(actorRef, msg) {
  dispatch$1(actorRef, msg);
}

function $great$neg$great(msg, actorRef) {
  dispatch$1(actorRef, msg);
}

function $less$question(actor, param) {
  return query(param[1], actor, param[0]);
}

var Operators = {
  $less$neg$less: $less$neg$less,
  $great$neg$great: $great$neg$great,
  $less$question: $less$question
};

function unsafeDecoder$1(prim) {
  return unsafeDecoder(prim);
}

function unsafeEncoder$1(prim) {
  return unsafeEncoder(prim);
}

var milliseconds = 1;

var millisecond = 1;

var second = seconds;

var minute = minutes;

var messages = 1;

var message = 1;

export {
  unsafeDecoder$1 as unsafeDecoder,
  unsafeEncoder$1 as unsafeEncoder,
  Interop ,
  ActorPath ,
  useStatefulSupervisionPolicy ,
  spawn ,
  spawnStateless ,
  spawnPersistent ,
  persistentQuery ,
  spawnAdapter ,
  start ,
  stop ,
  dispatch$1 as dispatch,
  nobody ,
  QueryTimeout ,
  query ,
  milliseconds ,
  millisecond ,
  seconds ,
  second ,
  minutes ,
  minute ,
  hours ,
  messages ,
  message ,
  Operators ,
}
/*  Not a pure module */
